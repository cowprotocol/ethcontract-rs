use crate::contract::Context;
use crate::util::expand_doc;
use proc_macro2::TokenStream;
use quote::quote;

pub(crate) fn expand(cx: &Context) -> TokenStream {
    let ethcontract = &cx.runtime_crate;
    let artifact_path = &cx.artifact_path;
    let contract_name = &cx.contract_name;

    let doc_str = cx
        .artifact
        .devdoc
        .details
        .as_deref()
        .unwrap_or("Generated by `ethcontract`");
    let doc = expand_doc(doc_str);

    quote! {
        #doc
        #[allow(non_camel_case_types)]
        pub struct #contract_name {
            instance: #ethcontract::DynInstance,
        }

        #[allow(dead_code)]
        impl #contract_name {
            /// Retrieves the truffle artifact used to generate the type safe API
            /// for this contract.
            pub fn artifact() -> &'static #ethcontract::Artifact {
                use #ethcontract::private::lazy_static;
                use #ethcontract::Artifact;

                lazy_static! {
                    pub static ref ARTIFACT: Artifact = {
                        Artifact::from_json(include_str!(#artifact_path))
                            .expect("valid artifact JSON")
                    };
                }
                &ARTIFACT
            }

            /// Creates a new contract instance with the specified `web3`
            /// provider at the given `Address`.
            ///
            /// Note that this does not verify that a contract with a maching
            /// `Abi` is actually deployed at the given address.
            pub fn at<F, T>(
                web3: &#ethcontract::web3::api::Web3<T>,
                address: #ethcontract::Address,
            ) -> Self
            where
                F: #ethcontract::web3::futures::Future<Item = #ethcontract::json::Value, Error = #ethcontract::web3::Error> + Send + 'static,
                T: #ethcontract::web3::Transport<Out = F> + 'static,
            {
                use #ethcontract::Instance;
                use #ethcontract::transport::DynTransport;
                use #ethcontract::web3::api::Web3;

                let transport = DynTransport::new(web3.transport().clone());
                let web3 = Web3::new(transport);
                let abi = Self::artifact().abi.clone();
                let instance = Instance::at(web3, abi, address);

                Self{ instance }
            }

            /// Returns the contract address being used by this instance.
            pub fn address(&self) -> #ethcontract::Address {
                self.instance.address()
            }

            /// Returns a reference to the default method options used by this
            /// contract.
            pub fn defaults(&self) -> &#ethcontract::contract::MethodDefaults {
                &self.instance.defaults
            }

            /// Returns a mutable reference to the default method options used
            /// by this contract.
            pub fn defaults_mut(&mut self) -> &mut #ethcontract::contract::MethodDefaults {
                &mut self.instance.defaults
            }
        }
    }
}
