use crate::contract::{methods, Context};
use crate::util;
use anyhow::Result;
use ethcontract_common::truffle::abi::{Param, ParamType};
use inflector::Inflector;
use proc_macro2::{Literal, TokenStream};
use quote::quote;

pub(crate) fn expand(cx: &Context) -> Result<TokenStream> {
    let ethcontract = &cx.runtime_crate;
    let contract_name = &cx.contract_name;

    let deployed = expand_deployed(&cx);
    let deploy = expand_deploy(&cx)?;

    Ok(quote! {
        impl #contract_name {
            #deployed
            #deploy
        }

        impl #ethcontract::contract::Deploy<#ethcontract::transport::DynTransport> for #contract_name {
            fn deployed_at(
                web3: #ethcontract::web3::api::Web3<#ethcontract::transport::DynTransport>,
                abi: #ethcontract::truffle::Abi,
                at: #ethcontract::Address,
            ) -> Self {
                use #ethcontract::Instance;

                // NOTE: we need to make sure that we were deployed with the
                //   correct ABI; luckily Abi implementes PartialEq
                debug_assert_eq!(abi, Self::artifact().abi);

                Self {
                    instance: Instance::at(web3, abi, at),
                }
            }
        }
    })
}

fn expand_deployed(cx: &Context) -> TokenStream {
    if cx.artifact.networks.is_empty() {
        return quote! {};
    }

    let ethcontract = &cx.runtime_crate;

    quote! {
        /// Locates a deployed contract based on the current network ID
        /// reported by the `web3` provider.
        ///
        /// Note that this does not verify that a contract with a maching
        /// `Abi` is actually deployed at the given address.
        pub fn deployed<F, T>(
            web3: &#ethcontract::web3::api::Web3<T>,
        ) -> #ethcontract::contract::DeployedFuture<#ethcontract::transport::DynTransport, Self>
        where
            F: #ethcontract::web3::futures::Future<Item = #ethcontract::json::Value, Error = #ethcontract::web3::Error> + Send + 'static,
            T: #ethcontract::web3::Transport<Out = F> + 'static,
        {
            use #ethcontract::Artifact;
            use #ethcontract::contract::DeployedFuture;
            use #ethcontract::transport::DynTransport;
            use #ethcontract::web3::api::Web3;

            let transport = DynTransport::new(web3.transport().clone());
            let web3 = Web3::new(transport);
            let artifact = { // only clone the pieces we need
                let artifact = Self::artifact();
                Artifact {
                    abi: artifact.abi.clone(),
                    networks: artifact.networks.clone(),
                    ..Artifact::empty()
                }
            };

            DeployedFuture::from_args(web3, artifact)
        }
    }
}

fn expand_deploy(cx: &Context) -> Result<TokenStream> {
    if cx.artifact.bytecode.is_empty() {
        // do not generate deploy method for contracts that have empty bytecode
        return Ok(quote! {});
    }

    let ethcontract = &cx.runtime_crate;

    // TODO(nlordell): not sure how contructor documentation get generated as I
    //   can't seem to get truffle to output it
    let doc = util::expand_doc("Generated by `ethcontract`");

    let (input, arg) = match cx.artifact.abi.constructor() {
        Some(contructor) => (
            methods::expand_inputs(cx, &contructor.inputs)?,
            methods::expand_inputs_call_arg(&contructor.inputs),
        ),
        None => (quote! {}, quote! {()}),
    };

    let lib_params: Vec<_> = cx
        .artifact
        .bytecode
        .undefined_libraries()
        .map(|name| Param {
            name: name.to_snake_case(),
            kind: ParamType::Address,
        })
        .collect();
    let lib_input = methods::expand_inputs(cx, &lib_params)?;

    let link = if !lib_params.is_empty() {
        let link_libraries = cx
            .artifact
            .bytecode
            .undefined_libraries()
            .zip(lib_params.iter())
            .map(|(name, lib_param)| {
                let name = Literal::string(&name);
                let address = util::ident(&lib_param.name);

                quote! {
                    artifact.bytecode.link(#name, #address).expect("valid library");
                }
            });

        quote! {
            let mut artifact = artifact;
            #( #link_libraries )*
        }
    } else {
        quote! {}
    };

    Ok(quote! {
        #doc
        pub fn builder<F, T>(
            web3: &#ethcontract::web3::api::Web3<T> #lib_input #input ,
        ) -> #ethcontract::DynDeployBuilder<Self>
        where
            F: #ethcontract::web3::futures::Future<Item = #ethcontract::json::Value, Error = #ethcontract::web3::Error> + Send + 'static,
            T: #ethcontract::web3::Transport<Out = F> + 'static,
        {
            use #ethcontract::{Artifact, DynTransport};
            use #ethcontract::contract::DeployBuilder;
            use #ethcontract::web3::api::Web3;

            let transport = DynTransport::new(web3.transport().clone());
            let web3 = Web3::new(transport);

            let artifact = { // only clone the pieces we need
                let artifact = Self::artifact();
                Artifact {
                    abi: artifact.abi.clone(),
                    bytecode: artifact.bytecode.clone(),
                    ..Artifact::empty()
                }
            };
            #link

            DeployBuilder::new(web3, artifact, #arg).expect("valid deployment args")
        }
    })
}
