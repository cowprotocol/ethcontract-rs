//! Implements artifact format generated by [hardhat-deploy] plugin.
//!
//! There are three distinct artifact formats.
//!
//! First is called "hardhat export", it is a JSON file that contains
//! information about a single network and all contracts deployed on it.
//! It can be generated with `hardhat export` command.
//!
//! Second is called "hardhat multi-export", it contains information about
//! multiple networks, for each network it contains information about
//! all contracts deployed on it. It can be generated with
//! `hardhat export --export-all` command.
//!
//! Both formats are supported by [`HardHatLoader`], see its documentation
//! for info and limitations.
//!
//! [hardhat-deploy]: https://github.com/wighawag/hardhat-deploy

use crate::artifact::Artifact;
use crate::contract::Network;
use crate::errors::ArtifactError;
use crate::{Address, Contract};
use serde::Deserialize;
use serde_json::Value;
use std::collections::HashMap;
use std::fs::File;
use std::path::Path;

/// Loads hardhat artifacts generated via `--export` and `--export-all`.
///
/// # Limitations
///
/// In hardhat, a contract could have different ABIs on different networks.
/// This could happen when deploying test versions of contracts.
/// Ethcontract does not support this. Parsing such artifact will result
/// in an error. You'll have to rename contracts, or filter out networks
/// with [`networks_allow_list`].
///
/// Another limitation is that hardhat allows having multiple networks
/// with the same chain ID. For example, you can have `rinkeby`
/// and `rinkeby-testing`. Both have chain ID of `4`, but contract addresses
/// and ABIs can be different. Ethcontract does not support this, so you'll
/// have to filter such networks. See [#545] for more info.
///
/// [#545]: https://github.com/gnosis/ethcontract-rs/issues/545.
pub struct HardHatLoader {
    /// Override for artifact's origin. If `None`, origin
    /// will be derived automatically.
    pub origin: Option<String>,

    /// List of allowed network names and chain IDs.
    ///
    /// When loading a contract, networks with names that aren't found
    /// in this list will be completely ignored. Contracts from these networks
    /// will not be loaded. You can use this mechanism to bypass
    /// the requirement that a contract must have the same ABI on all networks.
    ///
    /// Empty list means that all networks are allowed.
    pub networks_allow_list: Vec<String>,

    /// List of denied network names and chain IDs.
    ///
    /// When loading a contract, networks with names that are found
    /// in this list will be completely ignored.
    ///
    /// Empty list means that no networks are denied.
    pub networks_deny_list: Vec<String>,
}

/// Artifact format.
#[derive(Copy, Clone, Debug)]
pub enum Format {
    /// Contracts for a single network. Generated with `hardhat export`.
    SingleExport,

    /// Contracts for all networks. Generated with `hardhat export --export-all`.
    MultiExport,
}

impl HardHatLoader {
    /// Create a new hardhat loader.
    pub fn new() -> Self {
        HardHatLoader {
            origin: None,
            networks_deny_list: Vec::new(),
            networks_allow_list: Vec::new(),
        }
    }

    /// Create a new hardhat loader and set an override for artifact's origins.
    pub fn with_origin(origin: impl Into<String>) -> Self {
        HardHatLoader {
            origin: Some(origin.into()),
            networks_deny_list: Vec::new(),
            networks_allow_list: Vec::new(),
        }
    }

    /// Set new override for artifact's origin. See [`origin`] for more info.
    ///
    /// [`origin`]: #structfield.origin
    #[inline]
    pub fn origin(mut self, origin: Option<String>) -> Self {
        self.origin = origin;
        self
    }

    /// Add network name or id to the list of [`allowed networks`].
    ///
    /// [`allowed networks`]: #structfield.networks_allow_list
    #[inline]
    pub fn allow_network(mut self, network: impl Into<String>) -> Self {
        self.networks_allow_list.push(network.into());
        self
    }

    /// Add network name or id to the list of [`denied networks`].
    ///
    /// [`denied networks`]: #structfield.networks_deny_list
    #[inline]
    pub fn deny_network(mut self, network: impl Into<String>) -> Self {
        self.networks_deny_list.push(network.into());
        self
    }

    /// Parse a hardhat artifact from JSON string.
    pub fn load_from_string(&self, format: Format, json: &str) -> Result<Artifact, ArtifactError> {
        let origin = self
            .origin
            .clone()
            .unwrap_or_else(|| "<memory>".to_string());
        let mut artifact = Artifact::with_origin(origin);

        match format {
            Format::SingleExport => {
                self.fill_artifact(&mut artifact, serde_json::from_str(json)?)?
            }
            Format::MultiExport => {
                self.fill_artifact_multi(&mut artifact, serde_json::from_str(json)?)?
            }
        }

        Ok(artifact)
    }

    /// Loads a hardhat artifact from JSON value.
    pub fn load_from_json(&self, format: Format, value: Value) -> Result<Artifact, ArtifactError> {
        let origin = self
            .origin
            .clone()
            .unwrap_or_else(|| "<memory>".to_string());
        let mut artifact = Artifact::with_origin(origin);

        match format {
            Format::SingleExport => {
                self.fill_artifact(&mut artifact, serde_json::from_value(value)?)?
            }
            Format::MultiExport => {
                self.fill_artifact_multi(&mut artifact, serde_json::from_value(value)?)?
            }
        }

        Ok(artifact)
    }

    /// Loads a hardhat artifact from disk.
    pub fn load_from_file(&self, format: Format, path: &Path) -> Result<Artifact, ArtifactError> {
        let origin = self
            .origin
            .clone()
            .unwrap_or_else(|| path.display().to_string());
        let mut artifact = Artifact::with_origin(origin);

        let file = File::open(path)?;

        match format {
            Format::SingleExport => {
                self.fill_artifact(&mut artifact, serde_json::from_reader(file)?)?
            }
            Format::MultiExport => {
                self.fill_artifact_multi(&mut artifact, serde_json::from_reader(file)?)?
            }
        }

        Ok(artifact)
    }

    fn fill_artifact(
        &self,
        artifact: &mut Artifact,
        export: HardHatExport,
    ) -> Result<(), ArtifactError> {
        if self.allowed(&export.chain_id) && self.allowed(&export.chain_name) {
            for (name, contract_with_address) in export.contracts {
                let ContractWithAddress {
                    address,
                    mut contract,
                } = contract_with_address;

                contract.name = name;

                let mut contract = match artifact.get_mut(&contract.name) {
                    Some(existing_contract) => {
                        if existing_contract.abi != contract.abi {
                            return Err(ArtifactError::AbiMismatch(contract.name));
                        }

                        existing_contract
                    }
                    None => artifact.insert(contract).inserted_contract,
                };

                contract.networks_mut().insert(
                    export.chain_id.clone(),
                    Network {
                        address,
                        deployment_information: None,
                    },
                );
            }
        }

        Ok(())
    }

    fn fill_artifact_multi(
        &self,
        artifact: &mut Artifact,
        export: HashMap<String, HashMap<String, HardHatExport>>,
    ) -> Result<(), ArtifactError> {
        for (chain_id, export) in export {
            if !self.allowed(&chain_id) {
                continue;
            }

            let mut multiple_nets = false;

            for (chain_name, export) in export {
                if !self.allowed(&chain_name) {
                    continue;
                }

                if multiple_nets {
                    return Err(ArtifactError::DuplicateChain(chain_id));
                }

                self.fill_artifact(artifact, export)?;

                multiple_nets = true;
            }
        }

        Ok(())
    }

    fn allowed(&self, name: &str) -> bool {
        self.explicitly_allowed(name) && !self.explicitly_denied(name)
    }

    fn explicitly_allowed(&self, name: &str) -> bool {
        self.networks_allow_list.is_empty() || self.networks_allow_list.iter().any(|x| x == name)
    }

    fn explicitly_denied(&self, name: &str) -> bool {
        self.networks_deny_list.iter().any(|x| x == name)
    }
}

impl Default for HardHatLoader {
    fn default() -> Self {
        HardHatLoader::new()
    }
}

#[derive(Clone, Debug, Deserialize)]
struct HardHatExport {
    #[serde(rename = "name")]
    chain_name: String,
    #[serde(rename = "chainId")]
    chain_id: String,

    contracts: HashMap<String, ContractWithAddress>,
}

#[derive(Clone, Debug, Deserialize)]
struct ContractWithAddress {
    address: Address,
    #[serde(flatten)]
    contract: Contract,
}
