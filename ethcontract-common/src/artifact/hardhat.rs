//! Implements artifact format generated by [hardhat-deploy] plugin.
//!
//! There are three distinct artifact formats.
//!
//! First is called "hardhat export", it is a JSON file that contains
//! information about a single network and all contracts deployed on it.
//! It can be generated with `hardhat export` command.
//!
//! Second is called "hardhat multi-export", it contains information about
//! multiple networks, for each network it contains information about
//! all contracts deployed on it. It can be generated with
//! `hardhat export --export-all` command.
//!
//! Both formats are supported by [`HardHatLoader`], see its documentation
//! for info and limitations.
//!
//! [hardhat-deploy]: https://github.com/wighawag/hardhat-deploy

use crate::artifact::Artifact;
use crate::contract::Network;
use crate::errors::ArtifactError;
use crate::{Address, Contract};
use serde::Deserialize;
use serde_json::{from_reader, from_slice, from_str, from_value, Value};
use std::collections::HashMap;
use std::fs::File;
use std::io::{BufReader, Read};
use std::path::Path;

/// Loads hardhat artifacts generated via `--export` and `--export-all`.
///
/// # Limitations
///
/// In hardhat, a contract could have different ABIs on different networks.
/// This could happen when deploying test versions of contracts.
/// Ethcontract does not support this. Parsing such artifact will result
/// in an error. You'll have to rename contracts, or filter out networks
/// with [`networks_allow_list`].
///
/// Another limitation is that hardhat allows having multiple networks
/// with the same chain ID. For example, you can have `rinkeby`
/// and `rinkeby-testing`. Both have chain ID of `4`, but contract addresses
/// and ABIs can be different. Ethcontract does not support this, so you'll
/// have to filter such networks. See [#545] for more info.
///
/// [#545]: https://github.com/gnosis/ethcontract-rs/issues/545.
pub struct HardHatLoader {
    /// Override for artifact's origin. If `None`, origin
    /// will be derived automatically.
    pub origin: Option<String>,

    /// Artifact format.
    pub format: Format,

    /// List of allowed network names and chain IDs.
    ///
    /// When loading a contract, networks with names that aren't found
    /// in this list will be completely ignored. Contracts from these networks
    /// will not be loaded. You can use this mechanism to bypass
    /// the requirement that a contract must have the same ABI on all networks.
    ///
    /// Empty list means that all networks are allowed.
    pub networks_allow_list: Vec<NetworkEntry>,

    /// List of denied network names and chain IDs.
    ///
    /// When loading a contract, networks with names that are found
    /// in this list will be completely ignored.
    ///
    /// Empty list means that no networks are denied.
    ///
    /// Deny list takes precedence over allow list. That is, if network
    /// appears in both, it will be denied.
    pub networks_deny_list: Vec<NetworkEntry>,
}

impl HardHatLoader {
    /// Create a new hardhat loader.
    pub fn new(format: Format) -> Self {
        HardHatLoader {
            origin: None,
            format,
            networks_deny_list: Vec::new(),
            networks_allow_list: Vec::new(),
        }
    }

    /// Create a new hardhat loader and set an override for artifact's origins.
    pub fn with_origin(format: Format, origin: impl Into<String>) -> Self {
        HardHatLoader {
            origin: Some(origin.into()),
            format,
            networks_deny_list: Vec::new(),
            networks_allow_list: Vec::new(),
        }
    }

    /// Set new override for artifact's origin. See [`origin`] for more info.
    ///
    /// [`origin`]: #structfield.origin
    pub fn origin(mut self, origin: impl Into<String>) -> Self {
        self.origin = Some(origin.into());
        self
    }

    /// Set new format for artifacts.
    pub fn format(mut self, format: Format) -> Self {
        self.format = format;
        self
    }

    /// Add chain id to the list of [`allowed networks`].
    ///
    /// [`allowed networks`]: #structfield.networks_allow_list
    pub fn allow_by_chain_id(mut self, network: impl Into<String>) -> Self {
        self.networks_allow_list
            .push(NetworkEntry::ByChainId(network.into()));
        self
    }

    /// Add network name to the list of [`allowed networks`].
    ///
    /// [`allowed networks`]: #structfield.networks_allow_list
    pub fn allow_by_name(mut self, network: impl Into<String>) -> Self {
        self.networks_allow_list
            .push(NetworkEntry::ByName(network.into()));
        self
    }

    /// Add chain id to the list of [`denyid networks`].
    ///
    /// [`denied networks`]: #structfield.networks_deny_list
    pub fn deny_by_chain_id(mut self, network: impl Into<String>) -> Self {
        self.networks_deny_list
            .push(NetworkEntry::ByChainId(network.into()));
        self
    }

    /// Add network name to the list of [`denied networks`].
    ///
    /// [`denied networks`]: #structfield.networks_deny_list
    pub fn deny_by_name(mut self, network: impl Into<String>) -> Self {
        self.networks_deny_list
            .push(NetworkEntry::ByName(network.into()));
        self
    }

    /// Loads an artifact from a loaded JSON value.
    pub fn load_from_reader(&self, v: impl Read) -> Result<Artifact, ArtifactError> {
        self.load_artifact("<unknown>", v, from_reader, from_reader)
    }

    /// Loads an artifact from bytes of JSON text.
    pub fn load_from_slice(&self, v: &[u8]) -> Result<Artifact, ArtifactError> {
        self.load_artifact("<unknown>", v, from_slice, from_slice)
    }

    /// Loads an artifact from string of JSON text.
    pub fn load_from_str(&self, v: &str) -> Result<Artifact, ArtifactError> {
        self.load_artifact("<unknown>", v, from_str, from_str)
    }

    /// Loads an artifact from a loaded JSON value.
    pub fn load_from_value(&self, v: Value) -> Result<Artifact, ArtifactError> {
        self.load_artifact("<unknown>", v, from_value, from_value)
    }

    /// Loads an artifact from disk.
    pub fn load_from_file(&self, p: impl AsRef<Path>) -> Result<Artifact, ArtifactError> {
        let path = p.as_ref();
        let file = File::open(path)?;
        let reader = BufReader::new(file);
        self.load_artifact(path.display(), reader, from_reader, from_reader)
    }

    fn load_artifact<T>(
        &self,
        origin: impl ToString,
        source: T,
        single_loader: impl FnOnce(T) -> serde_json::Result<HardHatExport>,
        multi_loader: impl FnOnce(T) -> serde_json::Result<HardHatMultiExport>,
    ) -> Result<Artifact, ArtifactError> {
        let origin = self.origin.clone().unwrap_or_else(|| origin.to_string());

        let mut artifact = Artifact::with_origin(origin);

        match self.format {
            Format::SingleExport => {
                let loaded = single_loader(source)?;
                self.fill_artifact(&mut artifact, loaded)?
            }
            Format::MultiExport => {
                let loaded = multi_loader(source)?;
                self.fill_artifact_multi(&mut artifact, loaded)?
            }
        }

        Ok(artifact)
    }

    fn fill_artifact(
        &self,
        artifact: &mut Artifact,
        export: HardHatExport,
    ) -> Result<(), ArtifactError> {
        if self.allowed(&export.chain_id, &export.chain_name) {
            for (name, contract_with_address) in export.contracts {
                let ContractWithAddress {
                    address,
                    mut contract,
                } = contract_with_address;

                contract.name = name;

                let mut contract = match artifact.get_mut(&contract.name) {
                    Some(existing_contract) => {
                        if existing_contract.abi != contract.abi {
                            return Err(ArtifactError::AbiMismatch(contract.name));
                        }

                        existing_contract
                    }
                    None => artifact.insert(contract).inserted_contract,
                };

                let existing_network = contract.networks_mut().insert(
                    export.chain_id.clone(),
                    Network {
                        address,
                        deployment_information: None,
                    },
                );

                if existing_network.is_some() {
                    return Err(ArtifactError::DuplicateChain(export.chain_id));
                }
            }
        }

        Ok(())
    }

    fn fill_artifact_multi(
        &self,
        artifact: &mut Artifact,
        export: HardHatMultiExport,
    ) -> Result<(), ArtifactError> {
        for (_, export) in export.networks {
            for (_, export) in export {
                self.fill_artifact(artifact, export)?;
            }
        }

        Ok(())
    }

    fn allowed(&self, chain_id: &str, chain_name: &str) -> bool {
        !self.explicitly_denied(chain_id, chain_name)
            && (self.networks_allow_list.is_empty()
                || self.explicitly_allowed(chain_id, chain_name))
    }

    fn explicitly_allowed(&self, chain_id: &str, chain_name: &str) -> bool {
        self.networks_allow_list
            .iter()
            .any(|x| x.matches(chain_id, chain_name))
    }

    fn explicitly_denied(&self, chain_id: &str, chain_name: &str) -> bool {
        self.networks_deny_list
            .iter()
            .any(|x| x.matches(chain_id, chain_name))
    }
}

/// Artifact format.
#[derive(Copy, Clone, Debug)]
pub enum Format {
    /// Contracts for a single network. Generated with `hardhat export`.
    SingleExport,

    /// Contracts for all networks. Generated with `hardhat export --export-all`.
    MultiExport,
}

/// Network allow-deny entry.
#[derive(Clone, Debug)]
pub enum NetworkEntry {
    /// Network identified by chain ID.
    ByChainId(String),

    /// Network identified by its name specified in `hardhat.config.js`.
    ByName(String),
}

impl NetworkEntry {
    fn matches(&self, chain_id: &str, chain_name: &str) -> bool {
        match self {
            NetworkEntry::ByChainId(id) => chain_id == id,
            NetworkEntry::ByName(name) => chain_name == name,
        }
    }
}

#[derive(Deserialize)]
struct HardHatMultiExport {
    #[serde(flatten)]
    networks: HashMap<String, HashMap<String, HardHatExport>>,
}

#[derive(Deserialize)]
struct HardHatExport {
    #[serde(rename = "name")]
    chain_name: String,
    #[serde(rename = "chainId")]
    chain_id: String,

    contracts: HashMap<String, ContractWithAddress>,
}

#[derive(Deserialize)]
struct ContractWithAddress {
    address: Address,
    #[serde(flatten)]
    contract: Contract,
}

#[cfg(test)]
mod test {
    use super::*;
    use web3::ethabi::ethereum_types::BigEndianHash;
    use web3::types::{H256, U256};

    fn address(address: u8) -> Address {
        Address::from(H256::from_uint(&U256::from(address)))
    }

    #[test]
    fn load_single() {
        let json = r#"
          {
            "name": "mainnet",
            "chainId": "1",
            "contracts": {
              "A": {
                "address": "0x000000000000000000000000000000000000000A"
              },
              "B": {
                "address": "0x000000000000000000000000000000000000000B"
              }
            }
          }
        "#;

        let artifact = HardHatLoader::new(Format::SingleExport)
            .load_from_str(json)
            .unwrap();

        assert_eq!(artifact.len(), 2);

        let a = artifact.get("A").unwrap();
        assert_eq!(a.name, "A");
        assert_eq!(a.networks.len(), 1);
        assert_eq!(a.networks["1"].address, address(0xA));

        let b = artifact.get("B").unwrap();
        assert_eq!(b.name, "B");
        assert_eq!(b.networks.len(), 1);
        assert_eq!(b.networks["1"].address, address(0xB));
    }

    #[test]
    fn load_multi() {
        let json = r#"
          {
            "1": {
              "mainnet": {
                "name": "mainnet",
                "chainId": "1",
                "contracts": {
                  "A": {
                    "address": "0x000000000000000000000000000000000000000A"
                  },
                  "B": {
                    "address": "0x000000000000000000000000000000000000000B"
                  }
                }
              }
            },
            "4": {
              "rinkeby": {
                "name": "rinkeby",
                "chainId": "4",
                "contracts": {
                  "A": {
                    "address": "0x00000000000000000000000000000000000000AA"
                  }
                }
              }
            }
          }
        "#;

        let artifact = HardHatLoader::new(Format::MultiExport)
            .load_from_str(json)
            .unwrap();

        assert_eq!(artifact.len(), 2);

        let a = artifact.get("A").unwrap();
        assert_eq!(a.name, "A");
        assert_eq!(a.networks.len(), 2);
        assert_eq!(a.networks["1"].address, address(0xA));
        assert_eq!(a.networks["4"].address, address(0xAA));

        let b = artifact.get("B").unwrap();
        assert_eq!(b.name, "B");
        assert_eq!(b.networks.len(), 1);
        assert_eq!(b.networks["1"].address, address(0xB));
    }

    #[test]
    fn load_multi_duplicate_networks_ok() {
        let json = r#"
          {
            "1": {
              "mainnet": {
                "name": "mainnet",
                "chainId": "1",
                "contracts": {
                  "A": {
                    "address": "0x000000000000000000000000000000000000000A"
                  }
                }
              },
              "mainnet_beta": {
                "name": "mainnet_beta",
                "chainId": "1",
                "contracts": {
                  "B": {
                    "address": "0x000000000000000000000000000000000000000B"
                  }
                }
              }
            }
          }
        "#;

        let artifact = HardHatLoader::new(Format::MultiExport)
            .load_from_str(json)
            .unwrap();

        assert_eq!(artifact.len(), 2);

        let a = artifact.get("A").unwrap();
        assert_eq!(a.name, "A");
        assert_eq!(a.networks.len(), 1);
        assert_eq!(a.networks["1"].address, address(0xA));

        let b = artifact.get("B").unwrap();
        assert_eq!(b.name, "B");
        assert_eq!(b.networks.len(), 1);
        assert_eq!(b.networks["1"].address, address(0xB));
    }

    #[test]
    fn load_multi_duplicate_networks_err() {
        let json = r#"
          {
            "1": {
              "mainnet": {
                "name": "mainnet",
                "chainId": "1",
                "contracts": {
                  "A": {
                    "address": "0x000000000000000000000000000000000000000A"
                  }
                }
              },
              "mainnet_beta": {
                "name": "mainnet_beta",
                "chainId": "1",
                "contracts": {
                  "A": {
                    "address": "0x00000000000000000000000000000000000000AA"
                  }
                }
              }
            }
          }
        "#;

        let err = HardHatLoader::new(Format::MultiExport).load_from_str(json);

        match err {
            Err(ArtifactError::DuplicateChain(chain_id)) => assert_eq!(chain_id, "1"),
            Err(unexpected_err) => panic!("unexpected error {:?}", unexpected_err),
            _ => panic!("didn't throw an error"),
        }
    }

    #[test]
    fn load_multi_mismatching_abi() {
        let json = r#"
          {
            "1": {
              "mainnet": {
                "name": "mainnet",
                "chainId": "1",
                "contracts": {
                  "A": {
                    "address": "0x000000000000000000000000000000000000000A",
                    "abi": [
                      {
                        "constant": false,
                        "inputs": [],
                        "name": "foo",
                        "outputs": [],
                        "payable": false,
                        "stateMutability": "nonpayable",
                        "type": "function"
                      }
                    ]
                  }
                }
              }
            },
            "4": {
              "rinkeby": {
                "name": "rinkeby",
                "chainId": "4",
                "contracts": {
                  "A": {
                    "address": "0x00000000000000000000000000000000000000AA",
                    "abi": [
                      {
                        "constant": false,
                        "inputs": [],
                        "name": "bar",
                        "outputs": [],
                        "payable": false,
                        "stateMutability": "nonpayable",
                        "type": "function"
                      }
                    ]
                  }
                }
              }
            }
          }
        "#;

        let err = HardHatLoader::new(Format::MultiExport).load_from_str(json);

        match err {
            Err(ArtifactError::AbiMismatch(name)) => assert_eq!(name, "A"),
            Err(unexpected_err) => panic!("unexpected error {:?}", unexpected_err),
            _ => panic!("didn't throw an error"),
        }
    }

    static NETWORK_CONFLICTS: &str = r#"
      {
        "1": {
          "mainnet": {
            "name": "mainnet",
            "chainId": "1",
            "contracts": {
              "A": {
                "address": "0x000000000000000000000000000000000000000A"
              }
            }
          },
          "mainnet_beta": {
            "name": "mainnet_beta",
            "chainId": "1",
            "contracts": {
              "A": {
                "address": "0x00000000000000000000000000000000000000AA",
                "abi": [
                  {
                    "constant": false,
                    "inputs": [],
                    "name": "test_method",
                    "outputs": [],
                    "payable": false,
                    "stateMutability": "nonpayable",
                    "type": "function"
                  }
                ]
              }
            }
          }
        },
        "4": {
          "rinkeby": {
            "name": "rinkeby",
            "chainId": "4",
            "contracts": {
              "A": {
                "address": "0x00000000000000000000000000000000000000BA"
              }
            }
          }
        }
      }
    "#;

    #[test]
    fn load_multi_allow_by_name() {
        let artifact = HardHatLoader::new(Format::MultiExport)
            .allow_by_name("mainnet")
            .allow_by_name("rinkeby")
            .load_from_str(NETWORK_CONFLICTS)
            .unwrap();

        assert_eq!(artifact.len(), 1);

        let a = artifact.get("A").unwrap();
        assert_eq!(a.name, "A");
        assert_eq!(a.networks.len(), 2);
        assert_eq!(a.networks["1"].address, address(0xA));
        assert_eq!(a.networks["4"].address, address(0xBA));
    }

    #[test]
    fn load_multi_allow_by_chain_id() {
        let artifact = HardHatLoader::new(Format::MultiExport)
            .allow_by_chain_id("4")
            .load_from_str(NETWORK_CONFLICTS)
            .unwrap();

        assert_eq!(artifact.len(), 1);

        let a = artifact.get("A").unwrap();
        assert_eq!(a.name, "A");
        assert_eq!(a.networks.len(), 1);
        assert_eq!(a.networks["4"].address, address(0xBA));
    }

    #[test]
    fn load_multi_deny_by_name() {
        let artifact = HardHatLoader::new(Format::MultiExport)
            .deny_by_name("mainnet_beta")
            .load_from_str(NETWORK_CONFLICTS)
            .unwrap();

        assert_eq!(artifact.len(), 1);

        let a = artifact.get("A").unwrap();
        assert_eq!(a.name, "A");
        assert_eq!(a.networks.len(), 2);
        assert_eq!(a.networks["1"].address, address(0xA));
        assert_eq!(a.networks["4"].address, address(0xBA));
    }

    #[test]
    fn load_multi_deny_by_chain_id() {
        let artifact = HardHatLoader::new(Format::MultiExport)
            .deny_by_chain_id("1")
            .load_from_str(NETWORK_CONFLICTS)
            .unwrap();

        assert_eq!(artifact.len(), 1);

        let a = artifact.get("A").unwrap();
        assert_eq!(a.name, "A");
        assert_eq!(a.networks.len(), 1);
        assert_eq!(a.networks["4"].address, address(0xBA));
    }
}
